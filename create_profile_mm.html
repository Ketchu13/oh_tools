<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- SEO Metadata -->
    <meta name="description" content="Memetics builder for Once Human - Customize your build and share your setup.">
    <meta name="keywords" content="Once Human, memetics, build, profile, MMO, sci-fi, survival">
    <meta name="author" content="ketchu13">

    <!-- Language -->
    <meta http-equiv="Content-Language" content="en">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <!-- Favicon -->
    <link rel="icon" type="image/png" href="https://www.ketchu-free-party.fr/oh/favicon.ico">

    <!-- Page Title -->
    <title>Once Human - Memetics Builder</title>

    <!-- Open Graph for social sharing (Facebook, Discord, etc.) -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://www.ketchu-free-party.fr/oh/create_profile_mm.html?v=2">
    <meta property="og:title" content="Once Human - Memetics Profile Builder">
    <meta property="og:description"
        content="Create and share your Once Human Memetics build. View and optimize your setup easily.">
    <meta property="og:image" content="https://www.ketchu-free-party.fr/oh/prodimg/preview_cpmm.png?v=2">

    <style>
        :root {
            --bg-color: #36393f;
            --border-color: #72767d;
            --highlight: #5865f2;
            --input-bg: #202225;
            --text-color: #dcddde;
            --menu-txt-color: #5a7fa5;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
            padding: 20px;
        }

        #main_container {
            margin: auto;
            max-width: 800px;
            margin-bottom: 50px;
        }

        #header {
            margin-bottom: 10px;
            text-align: center;
        }

        /* Barre de menu sous le header */
        #menu_bar {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-bottom: 20px;
            border-bottom: 1px solid #72767d;
            border-top: 1px solid #72767d;
            padding-bottom: 8px;
            padding-top: 8px;
            font-weight: 600;
            font-size: 1.1rem;
            color: #dcddde;
        }

        #menu_bar a {
            color: #5a7fa5;
            text-decoration: none;
            padding-bottom: 4px;
            border-bottom: 3px solid transparent;
            border-top: 3px solid transparent;
            transition: border-color 0.3s, color 0.3s;
            cursor: pointer;
        }

        #menu_bar a:hover {
            color: #5865f2;
            border-bottom-color: #5865f2;
        }

        textarea,
        input,
        select,
        button {
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            color: var(--text-color);
            margin: 10px 0;
            padding: 8px;
            width: 100%;
            box-sizing: border-box;
        }

        button {
            background-color: var(--highlight);
            color: #fff;
            cursor: pointer;
        }

        button:hover {
            background-color: #4752c4;
        }

        .custom-dropdown-wrapper {
            margin-bottom: 15px;
        }

        .custom-dropdown {
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            color: var(--text-color);
            cursor: pointer;
            padding: 8px;
            position: relative;
            user-select: none;
        }

        .custom-dropdown .selected {
            align-items: center;
            display: flex;
            gap: 10px;
        }

        .custom-dropdown .options {
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            display: none;
            left: 0;
            max-height: 300px;
            overflow-y: auto;
            position: absolute;
            right: 0;
            top: 100%;
            z-index: 10;
            border-radius: 0 0 5px 5px;
        }

        .custom-dropdown .options.show {
            display: block;
        }

        .custom-dropdown .option {
            align-items: center;
            display: flex;
            gap: 10px;
            padding: 6px;
            cursor: pointer;
        }

        .custom-dropdown .option:hover {
            background-color: #40444b;
        }

        .custom-dropdown .option img {
            border-radius: 4px;
            height: 48px;
            width: 48px;
            user-select: none;
            pointer-events: none;
        }

        #input_container,
        #result_container,
        #qrcode_reader_container {
            max-width: 900px;
            width: 100%;
            background-color: #2f3136;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.6);
            border-radius: 5px;
        }

        h2,
        h1 {
            color: #fff;
            margin-bottom: 15px;
            padding-top: 0;
            margin-top: 0;
        }

        h1 {
            margin-bottom: 10px;
        }

        h4 {
            margin-top: 20px;
            margin-bottom: 10px;
            color: #b9bbbe;
        }

        #qrcode,
        #img_mm {
            width: 258px;
            height: 258px;
            margin: 20px auto 0 auto;

            overflow: hidden;
            border-radius: 5px;
            display: none;
        }

        #img_mm,
        #img_mm_pw {
            width: 278px !important;
            height: 545px !important;
            margin: 20px auto 0 auto;

            overflow: hidden;
            border-radius: 5px;
            display: none;
        }

        #img_mm canvas {
            width: 278px !important;
            height: 545px !important;
            display: block;
            margin: 0 auto;
            border-radius: 5px;
        }

        #img_mm_pw canvas {
            width: 278px !important;
            height: 545px !important;
            display: block;
            margin: 0 auto;
            border-radius: 5px;
        }

        #qrcode canvas {
            width: 258px !important;
            height: 258px !important;
            image-rendering: pixelated;
            display: block;
            margin: 0 auto;
            border-radius: 5px;
        }

        #downloadBtn,
        #downloadImgmmBtn {
            display: none;
            margin: 10px auto;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 5px;
            border: none;
            background-color: var(--highlight);
            color: white;
            cursor: pointer;
            display: block;
            max-width: 258px;
        }

        #downloadBtn:hover,
        #downloadImgmmBtn:hover {
            background-color: #4752c4;
        }

        .ribbon {
            position: fixed;
            top: 0;
            right: 0;
            z-index: 9999;
            overflow: hidden;
            width: 150px;
            height: 150px;
            pointer-events: none;
        }

        .ribbon span {
            position: absolute;
            display: block;
            width: 225px;
            padding: 10px 0;
            background: #5865F2;
            color: white;
            text-align: center;
            font-weight: bold;
            font-family: sans-serif;
            text-transform: uppercase;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
            top: 30px;
            right: -55px;
            transform: rotate(45deg);
            pointer-events: auto;
        }

        .neon {
            color: #00FFFF;
            text-shadow:
                0 0 5px #00FFFF,
                0 0 10px #00FFFF,
                0 0 20px #00FFFF;
        }

        /* Overlay full screen fond sombre transparent */
        #update-overlay {
            display: none;
            /* caché par défaut */
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(30, 30, 30, 0.9);
            backdrop-filter: blur(5px);
            z-index: 9999;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #ddd;
        }

        /* Box message centré */
        #update-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #2f3136;
            padding: 30px 40px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.7);
            text-align: center;
            max-width: 90%;
            width: 400px;
        }

        #update-box h2 {
            margin-bottom: 12px;
            font-size: 1.8em;
            color: #7289da;
            /* Discord blurple */
        }

        #update-box p {
            margin-bottom: 25px;
            font-size: 1.1em;
            line-height: 1.4;
            color: #b9bbbe;
        }

        #update-box button {
            background-color: #7289da;
            border: none;
            border-radius: 5px;
            padding: 12px 28px;
            color: white;
            font-weight: 600;
            font-size: 1em;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        #update-box button:hover {
            background-color: #5b6eae;
        }

        #tooltip {
            position: absolute;
            display: none;
            background: #18191c;
            border: 1px solid #202225;
            padding: 10px 12px;
            font-size: 14px;
            color: #dcddde;
            pointer-events: none;
            white-space: pre-line;
            max-width: 400px;
            border-radius: 5px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.9);
            z-index: 1000;
            user-select: none;
        }

        #last_profiles {
            border: 1px solid #72767d;
            background-color: #2f3136;
            width: 300px;
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            box-shadow: 5px 3px 8px rgba(0, 0, 0, 0.5);
            margin-bottom: 20px;
            position: absolute;
            padding-bottom: 4px;
            text-align: center;
            right: 20px;
            top: 150px;
        }

        #last_profiles h2 {
            margin-top: 0;
            color: #fff;
            font-size: 16px;
            width: 100%;
            text-align: center;
            margin-bottom: 0;
        }

        #last_profiles p {
            color: #b9bbbe;
            font-size: 14px;
            margin-bottom: 4px;
            width: 100%;
            text-align: center;
            margin-top: 5px;
        }

        li {
            list-style: none;
            margin: 5px 0;
            padding: 5px;
            background-color: #40444b;
            border-radius: 3px;
            color: #dcddde;
            font-size: 14px;
        }

        ul {
            padding: 0%;
            margin: 0;
        }
    </style>
    <script src="./js/qrcode.min.js"></script>
    <!-- Firebase App (compat) -->
    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
    <!-- Firebase Firestore (compat) -->
    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore-compat.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>

</head>

<body>
    <a href="#" class="ribbon" title="Work in progress">
        <span>BETA VERSION</span>
    </a>
    <div id="main_container">
        <div id="header">
            <h1>Once Human - Memetics</h1>
        </div>
        <nav id="menu_bar">
            <a href="index.html">QR Code Reader</a>
            <a href="#input_container">Memetics Profile Generator</a>
        </nav>
        <div id="input_container">
            <h4>Memetics Profile Generator</h4>
            <label for="player">User Name</label>
            <input type="text" id="player" name="player" placeholder="Rosetta42" />
            <label for="server">Serveur</label>
            <input type="text" id="server" name="server" placeholder="Manibus-X179" value="Manibus-X179" />
            <label for="level">Level</label>
            <input type="number" id="level" name="level" value="50" />
            <h4>Choose Memetics Slots</h4>
            <div id="memetic_slots"></div>
            <button onclick="generateProfile()">Generate Memetics profile</button>
            <div id="qrcode"></div>
            <button id="downloadBtn" style="display: none;">Download QR Code</button>
            <div id="img_mm"></div>
            <button id="downloadImgmmBtn" style="display: none;">Download image</button>
            <pre id="output"></pre>
        </div>
        <!-- Tu peux ajouter ici plus tard une section QR code reader avec id="qrcode_reader_container" -->
    </div>
    <div id="last_profiles">
        <h2>Last Memetics Profiles</h2>
        <p>Last 3 profiles saved in the database:</p>
        <ul id="last_profiles_list"></ul>
        <div id="img_mm_pw"></div>
    </div>
    <footer style="background-color: #1e1f22; color: #888; text-align: center; padding: 5px; font-size: 0.85rem;">
        <p style="margin: 0;">Personal project by <strong>ketchu13</strong> aka <strong>Søuris</strong> — <span
                style="opacity: 0.8;">2025</span></p>
        <p style="margin: 0;font-size: 0.75rem; color: #666;">Not affiliated with Starry Studio or the game <em>Once
                Human</em></p>
    </footer>

    <div id="tooltip"></div>
    <div id="update-overlay">
        <div id="update-box">
            <h2>Hey! 🚀 Update detected!</h2>
            <p>A new version of this page is available.<br />Please reload to get the latest and greatest.</p>
            <button id="reload-btn">Reload Now</button>
        </div>
    </div>
    <script>

        let memeticsData = [];
        let lastThreeProfiles = [];

        const params = new URLSearchParams(window.location.search);
        const profileID = params.get('profile_id');

        const imgempty = new Image();

        imgempty.src = './memetics_icons_cropped/empty.png';
        imgempty.width = 96;
        imgempty.height = 96;
        imgempty.alt = 'empty';
        // Configuration Firebase
        const firebaseConfig = {
            apiKey: "AIzaSyB2_wLWe9dElA_jqlkxkfLldBzXeXa5l8U",
            authDomain: "oncehumank13tools.firebaseapp.com",
            projectId: "oncehumank13tools",
            storageBucket: "oncehumank13tools.firebasestorage.app",
            messagingSenderId: "766110090627",
            appId: "1:766110090627:web:e8547f7018ff3777ff22b6",
            measurementId: "G-YX55LK87YH"
        };

        // Initialisation
        const app = firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();

        function compressAndEncode(data) {
            const binary = pako.deflate(data);
            return btoa(String.fromCharCode(...binary));
        }
        function decodeAndDecompress(encoded) {
            // Décodage base64 → binaire (Uint8Array)
            const binaryString = atob(encoded);
            const binary = new Uint8Array([...binaryString].map(c => c.charCodeAt(0)));

            // Décompression zlib
            const data = pako.inflate(binary, { to: 'string' });

            // Parse JSON
            return data;
        }
        async function getLastThreeProfiles() {
            try {
                const snapshot = await db
                    .collection("memetics_profiles")
                    .orderBy("createdAt", "desc")
                    .limit(3)
                    .get();

                const profiles = [];
                snapshot.forEach(doc => {
                    profiles.push({ id: doc.id, ...doc.data() });
                });

                console.log("Derniers profils :", profiles);
                return profiles;
            } catch (error) {
                console.error("Erreur lors de la récupération des profils :", error);
                return [];
            }
        }

        function saveProfileToFirestore(player, server, level, memetics) {
            const profileData = {
                player: player,
                server: server,
                level: level,
                memetics: memetics,
                createdAt: firebase.firestore.FieldValue.serverTimestamp()
            };

            return db.collection('memetics_profiles').add(profileData)
                .then((docRef) => {
                    console.log('Profile saved successfully!');
                    console.log('Document ID:', docRef.id);
                    return docRef.id; // ✅ renvoie l'ID du document
                })
                .catch((error) => {
                    console.error('Error saving profile:', error);
                    throw error; // ✅ permet au code appelant de gérer l'erreur
                });
        }
        async function getProfileById(id) {
            try {
                const docRef = db.collection("memetics_profiles").doc(id);
                const doc = await docRef.get();

                if (doc.exists) {
                    console.log("Profil trouvé :", doc.data());
                    return { id: doc.id, ...doc.data() };
                } else {
                    console.log("Aucun profil trouvé avec l'ID :", id);
                    return null;
                }
            } catch (error) {
                console.error("Erreur lors de la récupération du profil :", error);
                return null;
            }
        }
        async function getLatestCommitSHA(owner, repo, branch = 'main') {
            const url = `https://api.github.com/repos/${owner}/${repo}/commits/${branch}`;
            try {
                const response = await fetch(url);
                remaining = response.headers.get('X-RateLimit-Remaining');
                if (remaining === '0') {
                    console.warn('GitHub API rate limit reached. Please try again later.');
                    return null;
                }
                if (!response.ok) throw new Error(`GitHub API error: ${response.status}`);
                const data = await response.json();
                return data.sha.substring(0, 7);
            } catch (error) {
                console.error('Failed to fetch latest commit SHA:', error);
                return null;
            }
        }
        function loadLastThreeProfiles() {
            getLastThreeProfiles().then(profiles => {
                lastThreeProfiles = profiles;
                const list = document.getElementById('last_profiles_list');
                list.innerHTML = ''; // On vide la liste avant de la remplir à nouveau

                if (profiles.length === 0) {
                    list.innerHTML = '<li>No profiles found.</li>';
                    return;
                }

                profiles.forEach(profile => {
                    const li = document.createElement('li');
                    let player_name = "";
                    for (let i = 0; i < profile.player.length; i++) {
                        if (i >= 1 && i < profile.player.length - 1) {
                            player_name += '*';
                        } else {
                            player_name += profile.player[i];
                        }
                    }

                    li.textContent = `${player_name} (${profile.server})`;
                    li.dataset.id = profile.id;
                    const tooltip = document.getElementById('img_mm_pw');

                    li.addEventListener('mouseenter', () => {
                        generatPicture(profile.memetics, player_name, profile.server, tooltip);
                        tooltip.style.display = 'block';
                    });

                    li.addEventListener('mouseleave', () => {
                        tooltip.style.display = 'none';
                        tooltip.innerHTML = '';
                    });

                    li.onclick = (e) => {
                        e.stopPropagation();
                        webkitURL = window.webkitURL || window.URL;
                        const profileId = li.dataset.id;
                        const url = new URL(window.location.href);
                        url.searchParams.set('profile_id', profileId);
                        window.location.href = url.toString();
                    };

                    list.appendChild(li);
                });
            });
        }

        function fitTextToWidth(ctx, text, maxWidth, initialFontSize = 13, minFontSize = 6, fontFamily = "Arial") {
            let fontSize = initialFontSize;

            // On descend jusqu'à ce que ça rentre ou qu'on atteigne la taille minimale
            while (fontSize >= minFontSize) {
                ctx.font = `${fontSize}px ${fontFamily}`;
                const metrics = ctx.measureText(text);
                if (metrics.width <= maxWidth) {
                    return fontSize;
                }
                fontSize -= 1;
            }

            // Si aucun ne passe, retourne la taille minimale
            return minFontSize;
        }

        function showUpdateOverlay() {
            document.getElementById('update-overlay').style.display = 'block';
        }
        function reloadPage() {
            // Tenter de vider le cache (reload complet)
            // location.reload(true) est déprécié, donc on force reload avec un timestamp unique dans l'URL
            const url = new URL(window.location.href);
            url.searchParams.set('_', Date.now());
            window.location.href = url.toString();
        }
        function startCheckingUpdates(owner, repo, branch = 'main', intervalMs = 300000) {
            let lastSHA = null;

            async function check() {
                const latestSHA = await getLatestCommitSHA(owner, repo, branch);
                if (!latestSHA) return;

                if (lastSHA && latestSHA !== lastSHA) {
                    console.log('Update detected! New commit:', latestSHA);
                    showUpdateOverlay();
                } else if (!lastSHA) {
                    console.log('Initial commit SHA:', latestSHA);
                } else {
                    console.log('No update. Current commit SHA:', latestSHA);
                }

                lastSHA = latestSHA;
            }

            check();
            setInterval(check, intervalMs);
        }

        function escapeHTML(str) {
            return String(str).replace(/[&<>"']/g, (m) => ({
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#39;',
            })[m]);
        }

        function generateMemeticsTableImage(part1, part2, levelImageMap) {
            const tileSize = 96; // taille de l'image
            const padding = 3;
            const fontSize = 13;
            const headerHeight = 50;
            const rowHeight = tileSize + padding;
            const rows = 5;
            const cols = 4;
            const canvasWidth = 13 + 30 + tileSize + 13 + 30 + tileSize + 13;
            const canvasHeight = headerHeight + rows * rowHeight + 13;

            const canvas = document.createElement('canvas');
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            canvas.style.borderRadius = '5px';
            const ctx = canvas.getContext('2d');
            //reduce size of part1 and part2 to 50
            part1 = part1.length > 20 ? part1.substring(0, 20) + '...' : part1;
            part2 = part2.length > 30 ? part2.substring(0, 30) + '...' : part2;
            if (part1.length + part2.length > 50) {
                part1 = part1.substring(0, 20) + '...';
                part2 = part2.substring(0, 30) + '...';
            }
            // Fond
            ctx.fillStyle = '#1e1e1e';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            // Header
            ctx.fillStyle = 'white';
            const fontSized = fitTextToWidth(ctx, `${part1} - ${part2}`, 545);
            ctx.font = `bold ${fontSized}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText(`${part1} - ${part2}`, canvasWidth / 2, 30);

            // Colonnes gauche (5 → 25) et droite (30 → 50)
            const leftLevels = [5, 10, 15, 20, 25];
            const rightLevels = [30, 35, 40, 45, 50];

            ctx.font = `${fontSize}px sans-serif`;
            ctx.textAlign = 'left';

            for (let i = 0; i < rows; i++) {
                const y = headerHeight + i * rowHeight + fontSize / 2 + rowHeight / 2;

                // Colonne 1 : niveau gauche
                ctx.fillStyle = 'white';
                ctx.fillText(`${leftLevels[i]}`, 13, y);

                // Colonne 2 : image gauche
                const imgLeft = levelImageMap[leftLevels[i]];
                if (imgLeft) {
                    ctx.drawImage(
                        imgLeft,
                        13 + 30,
                        headerHeight + i * rowHeight,
                        tileSize,
                        tileSize
                    );
                }

                // Colonne 3 : niveau droite
                ctx.fillText(`${rightLevels[i]}`, 13 + 30 + tileSize + 13, y);

                // Colonne 4 : image droite
                const imgRight = levelImageMap[rightLevels[i]];
                if (imgRight) {
                    ctx.drawImage(
                        imgRight,
                        13 + 30 + tileSize + 13 + 30,
                        headerHeight + i * rowHeight,
                        tileSize,
                        tileSize
                    );
                }
            }

            return canvas;
        }
        async function generatPicture(profile_memetics, player_name, server, img_elem) {
            img_elem.style.display = 'block';
            img_elem.innerHTML = '';
            const levelImageMap = {};
            const levels = Array.from({ length: 10 }, (_, i) => (i + 1) * 5); // [5,10,...,50]

            // Fonction pour charger une image et garantir qu'elle est prête
            function loadImage(src, alt = 'memetic', width = 96, height = 96) {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.src = src;
                    img.alt = alt;
                    img.width = width;
                    img.height = height;
                    img.onload = () => resolve(img);
                    img.onerror = () => {
                        console.warn(`Échec de chargement : ${src}, fallback utilisé.`);
                        const fallback = new Image();
                        fallback.src = './memetics_icons_cropped/empty.png';
                        fallback.alt = 'empty';
                        fallback.width = width;
                        fallback.height = height;
                        fallback.onload = () => resolve(fallback);
                        fallback.onerror = () => resolve(fallback); // au pire, on continue
                    };
                });
            }

            // On initialise avec des images vides (distinctes)
            for (const level of levels) {
                levelImageMap[level] = await loadImage('./memetics_icons_cropped/empty.png', 'empty');
            }

            // On remplace par les bonnes images si on trouve les bons memetics
            for (let index = 0; index < profile_memetics.length; index++) {
                const memeticId = profile_memetics[index];
                if (!memeticId) continue;

                const memetic = memeticsData.find(m => m.id === parseInt(memeticId));
                if (!memetic) {
                    console.warn(`Memetic with ID ${memeticId} not found.`);
                    continue;
                }

                const level = (index + 1) * 5;
                const img = await loadImage('./memetics_icons_cropped/' + memetic.imgUrl, memetic.name);
                levelImageMap[level] = img;
            }

            const part1 = player_name || 'Profile';
            const part2 = server || 'Server';
            const canvas_mm = generateMemeticsTableImage(part1, part2, levelImageMap);
            img_elem.appendChild(canvas_mm);
        }

        function populateSelects() {
            const slots = [5, 10, 15, 20, 25, 30, 35, 40, 45, 50];
            const container = document.getElementById('memetic_slots');

            slots.forEach((level) => {
                const wrapper = document.createElement('div');
                wrapper.className = 'custom-dropdown-wrapper';

                const label = document.createElement('label');
                label.textContent = `Level ${level}`;
                wrapper.appendChild(label);

                const hiddenInput = document.createElement('input');
                hiddenInput.type = 'hidden';
                hiddenInput.name = `s${level}`;
                hiddenInput.id = `s${level}`;
                wrapper.appendChild(hiddenInput);

                const dropdown = document.createElement('div');
                dropdown.className = 'custom-dropdown';
                dropdown.tabIndex = 0;

                const selected = document.createElement('div');
                selected.className = 'selected';
                selected.textContent = 'Select a memetic for level ' + level + '...';
                dropdown.appendChild(selected);

                const options = document.createElement('div');
                options.className = 'options';

                const tooltip = document.getElementById('tooltip');
                // sort alphabetically by name
                memeticsData.sort((a, b) => a.name.localeCompare(b.name));
                memeticsData.forEach((item) => {
                    // on ajoute l'item que s'il est compatible avec le niveau su slot
                    // item.levels est une liste de niveaux compatibles
                    if (item.levels.includes(level)) {

                        const option = document.createElement('div');
                        option.className = 'option';
                        option.dataset.value = item.id;

                        const img = document.createElement('img');
                        img.src = './memetics_icons_cropped/' + item.imgUrl;
                        img.alt = item.name;
                        img.width = 48;
                        img.height = 48;

                        const span = document.createElement('span');
                        span.textContent = item.name;

                        option.appendChild(img);
                        option.appendChild(span);
                        options.appendChild(option);
                        option.addEventListener('mouseenter', e => {
                            tooltip.innerHTML = `<strong>${item.effect_description}</strong><br>${item.effect_title}`;
                            tooltip.style.display = 'block';
                        });

                        option.addEventListener('mousemove', e => {
                            tooltip.style.left = (e.pageX + 15) + 'px';
                            tooltip.style.top = (e.pageY + 15) + 'px';
                        });

                        option.addEventListener('mouseleave', () => {
                            tooltip.style.display = 'none';
                        });
                        option.onclick = (e) => {
                            e.stopPropagation();
                            selected.textContent = '';
                            const cloneImg = img.cloneNode(true);
                            selected.appendChild(cloneImg);
                            selected.appendChild(document.createTextNode(' ' + item.name));
                            hiddenInput.value = item.id;
                            options.classList.remove('show');
                        };
                    }
                });


                dropdown.appendChild(options);

                dropdown.onclick = (e) => {
                    e.stopPropagation();
                    // Fermer les autres dropdowns ouvertes
                    document.querySelectorAll('.custom-dropdown .options.show').forEach((el) => {
                        if (el !== options) el.classList.remove('show');
                    });
                    options.classList.toggle('show');
                };

                wrapper.appendChild(dropdown);
                container.appendChild(wrapper);
            });
        }
        function generateQRCode(memetics_d_, profile_id, player, server, level) {

            const qrSize = 526;
            const borderSize = 40;

            const tempDiv = document.createElement('div');
            tempDiv.style.position = 'absolute';
            tempDiv.style.left = '-9999px';
            document.body.appendChild(tempDiv);
            // version url
            new_data_url = `https://www.oh-tools.com/?profile_id=${profile_id}`;
            new QRCode(tempDiv, {
                text: new_data_url,
                width: qrSize,
                height: qrSize,
                colorDark: '#000000',
                colorLight: '#ffffff',
                correctLevel: QRCode.CorrectLevel.H,
            });

            setTimeout(() => {
                // Vérifier si le QR code a été généré correctement
                const qrCanvas = tempDiv.querySelector('canvas');
                if (!qrCanvas) {
                    alert('Error generating QR code. Please try again.');
                }
                const logo_width = 64;

                // Créer un canvas final pour ajouter le QR code et les textes
                const finalCanvas = document.createElement('canvas');
                finalCanvas.width = qrSize + borderSize * 2;
                finalCanvas.height = qrSize + borderSize * 2;

                // Créer le contexte de dessin
                const ctx = finalCanvas.getContext('2d');

                // Fond blanc
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, finalCanvas.width, finalCanvas.height);

                // Dessiner QR code au centre avec bordure
                ctx.drawImage(qrCanvas, borderSize, borderSize);

                // Ajouter le nom du personnage en haut et le server en bas
                ctx.fillStyle = '#000000';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.borderRadius = '5px';
                ctx.fillText(player || 'Username', finalCanvas.width / 2, 28);
                ctx.fillText(server || 'Server', finalCanvas.width / 2, finalCanvas.height - 10);

                // get image from file
                img_logo = new Image();
                img_logo.src = './prodimg/oh64x64.png';

                // ajout de l'image du logo au centre avec une taille de 32x32 pixels
                img_logo.onload = () => {
                    ctx.drawImage(img_logo, (finalCanvas.width - logo_width) / 2, (finalCanvas.height - logo_width) / 2, logo_width, logo_width);
                };
                img_logo.onerror = () => {
                    console.error('Failed to load the logo image.');
                };

                // Nettoyer temporaire
                tempDiv.remove();

                // Afficher le QR code dans le div prévu
                const qrcodeDiv = document.getElementById('qrcode');
                qrcodeDiv.style.display = 'block';
                qrcodeDiv.innerHTML = '';
                qrcodeDiv.appendChild(finalCanvas);

                // Afficher le bouton de téléchargement
                const downloadBtn = document.getElementById('downloadBtn');
                downloadBtn.style.display = 'block';
                downloadBtn.onclick = () => {
                    const link = document.createElement('a');
                    link.download = `oncehuman_memetics_profile_${player || 'profile'}.png`;
                    link.href = finalCanvas.toDataURL('image/png');
                    link.click();
                };

                const img_mm = document.getElementById('img_mm');
                img_mm.style.display = 'block';
                img_mm.innerHTML = '';
                const levelImageMap = {};
                const imgempty = new Image();
                imgempty.src = './memetics_icons_cropped/empty.png';
                imgempty.width = 96;
                imgempty.height = 96;
                imgempty.alt = 'empty';
                for (let i = 5; i <= 50; i += 5) {
                    levelImageMap[i] = imgempty; // initialise avec une image vide
                }
                memetics_d_.forEach((memeticId, index) => {
                    if (memeticId) {
                        const memetic = memeticsData.find(m => m.id === parseInt(memeticId));
                        if (!memetic) {
                            console.warn(`Memetic with ID ${memeticId} not found.`);
                            return;
                        }
                        if (memetic) {
                            const img = new Image();
                            img.src = './memetics_icons_cropped/' + memetic.imgUrl;
                            img.width = 96;
                            img.height = 96;
                            img.alt = memetic.name;
                            levelImageMap[(index + 1) * 5] = img; // map niveau à l'image
                        }
                    }
                });
                const part1 = player || 'Profile';
                const part2 = server || 'Server';
                const canvas_mm = generateMemeticsTableImage(part1, part2, levelImageMap);
                img_mm.appendChild(canvas_mm);
                const downloadImgmmBtn = document.getElementById('downloadImgmmBtn');
                downloadImgmmBtn.style.display = 'block';
                downloadImgmmBtn.onclick = () => {
                    const link = document.createElement('a');
                    link.download = `oncehuman_memetics_table_${part1}_${part2}.png`;
                    link.href = canvas_mm.toDataURL('image/png');
                    link.click();
                };

            }, 50);
        }

        function generateProfile() {
            // Récupère les valeurs des champs
            const player = document.getElementById('player').value.trim();
            const server = document.getElementById('server').value.trim();
            const level = parseInt(document.getElementById('level').value) || 0;

            if (!player || !server || !level) {
                alert('Please fill in all fields: Player Name, Server, and Level.');
                return;
            }

            data = player + '#' + server + '#' + level + '#';

            // Récupère tous les selects custom
            const inputs = document.querySelectorAll('#memetic_slots input[type="hidden"]');
            memetics_d = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
            inputs.forEach((input) => {
                if (input.value) {
                    const levelIndex = parseInt(input.name.replace('s', '')) / 5 - 1; // Convertit s5, s10, ... en index 0, 1, ...
                    memetics_d[levelIndex] = input.value;
                }
            });

            // Ajout des memetics sélectionnés
            data += memetics_d.join(',') + '#';
            // debug
            //const outputPre = document.getElementById('output');
            //outputPre.textContent = data
            saveProfileToFirestore(player, server, level, memetics_d)
                .then((docId) => {
                    console.log('Enregistré avec ID :', docId);
                    generateQRCode(memetics_d, docId, player, server, level);
                })
                .catch((err) => {
                    alert('Erreur lors de la sauvegarde du profil.');
                });
        }
        // fonction async qui charge le JSON et le stocke
        async function loadJsonBeforePage() {
            try {
                const response = await fetch('./memetics.json');
                if (!response.ok) throw new Error('Erreur HTTP ' + response.status);
                const data = await response.json();
                memeticsData = data.memetics;
                populateSelects();
            } catch (e) {
                console.error('Erreur lors du chargement JSON:', e);
                // Tu peux choisir un fallback ici
                window.myGlobalDict = {};
            }
        }
        document.addEventListener('DOMContentLoaded', () => {
            loadJsonBeforePage()
                .then(() => {
                    console.log('Memetics data loaded successfully.');
                })
                .catch((error) => {
                    console.error('Failed to load memetics data:', error);
                });
            // Lancer la vérification
            startCheckingUpdates('ketchu13', 'oh_tools', 'main', 60 * 1000); // check toutes les 10 secondes
            // Charger une première fois au démarrage
            loadLastThreeProfiles();
            setInterval(() => {
                loadLastThreeProfiles();
            }, 30 * 1000); // Recharger toutes les 30 secondes pour le devbug
            //Ferme les dropdown si clic hors dropdown
            document.addEventListener('click', () => {
                document.querySelectorAll('.custom-dropdown .options.show').forEach((el) => {
                    el.classList.remove('show');
                });
            });

        });
        document.getElementById('reload-btn').addEventListener('click', reloadPage);


    </script>
</body>

</html>