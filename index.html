<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- SEO Metadata -->
    <meta name="description" content="Memetics Resource for Once Human. Create and share your Memetics builds easily.">
    <meta name="keywords" content="Once Human, memetics, build, profile, MMO, sci-fi, survival">
    <meta name="author" content="ketchu13">

    <!-- Language -->
    <meta http-equiv="Content-Language" content="en">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <!-- Favicon -->
    <link rel="icon" type="image/png" href="https://www.ketchu-free-party.fr/oh/favicon.ico">

    <!-- Page Title -->
    <title>Once Human - Memetics Profile Viewer</title>

    <!-- Open Graph for social sharing (Facebook, Discord, etc.) -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://www.ketchu-free-party.fr/oh/index.html">
    <meta property="og:title" content="Once Human - Memetics Profiles Manager">
    <meta property="og:description"
        content="Memetics Resource for Once Human. Create and share your Memetics builds easily..">
    <meta property="og:image" content="https://www.ketchu-free-party.fr/oh/prodimg/index.png?v=2">

    <title>Once Human - Memetics</title>
    <style>
        :root {
            --bg-color: #36393f;
            --border-color: #72767d;
            --highlight: #5865f2;
            --input-bg: #202225;
            --text-color: #dcddde;
            --menu-txt-color: #5a7fa5;
        }

        body {
            background-color: #36393f;
            color: #dcddde;
            font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
            justify-content: center;
            padding: 20px;

        }

        #main_container {
            margin: auto;
            max-width: 800px;
            margin-bottom: 50px;
        }

        #header {
            margin-bottom: 10px;
            text-align: center;
        }

        #menu_bar {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-bottom: 20px;
            border-bottom: 1px solid #72767d;
            border-top: 1px solid #72767d;
            padding-bottom: 8px;
            padding-top: 8px;
            font-weight: 600;
            font-size: 1.1rem;
            color: #dcddde;
        }

        #menu_bar a {
            color: #5a7fa5;
            text-decoration: none;
            padding-bottom: 4px;
            border-bottom: 3px solid transparent;
            border-top: 3px solid transparent;
            transition: border-color 0.3s, color 0.3s;
            cursor: pointer;
        }

        #menu_bar a:hover {
            color: #5865f2;
            border-bottom-color: #5865f2;
        }

        #input_container,
        #result_container,
        #qrcode_reader_container {
            max-width: 900px;
            width: 100%;
            background-color: #2f3136;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.6);
        }

        p {
            margin: 0;
        }

        #input_container {
            padding-top: 10px;
        }

        #result_container {
            margin-top: 20px;
            margin-bottom: 50px;
        }

        #qrcode_reader_container {
            padding-top: 20px;
            margin-top: 20px;
        }

        .upload-button {
            display: inline-block;
            padding: 10px 20px;
            background-color: #5865f2;
            /* Discord blurple */
            color: white;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s ease;
            font-family: sans-serif;
            user-select: none;
        }

        .upload-button:hover {
            background-color: #4752c4;
        }

        .upload-button input[type="file"] {
            display: none;
        }

        h2 {
            color: #fff;
            margin-bottom: 15px;
            padding-top: 0px;
            margin-top: 0px;
        }

        h1 {
            color: #fff;
            margin-bottom: 20px;
            padding-top: 0px;
            margin-top: 0px;
        }

        h2,
        h1 {
            color: #fff;
            margin-bottom: 10px;
            padding-top: 0;
            margin-top: 0;
        }

        h4 {
            margin-top: 20px;
            margin-bottom: 10px;
            color: #b9bbbe;
        }

        .info {
            margin-top: 20px;
            margin-bottom: 20px;
            font-weight: 500;
        }

        textarea {
            width: -webkit-fill-available;
            height: 230px;
            margin-bottom: 15px;
            background-color: #202225;
            border: 1px solid #202225;
            border-radius: 5px;
            color: #dcddde;
            font-family: monospace;
            padding: 10px;
            resize: vertical;
        }

        textarea::placeholder {
            color: #72767d;
        }

        button {
            background-color: #5865f2;
            border: none;
            color: white;
            font-weight: 600;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        button:hover {
            background-color: #4752c4;
        }

        .tile {
            display: flex;
            align-items: center;
            border: 1px solid #202225;
            background-color: #292b2f;
            margin-bottom: 10px;
            padding: 8px 12px;
            height: 64px;
            border-radius: 6px;
            position: relative;
            transition: background-color 0.2s ease;
            cursor: default;
        }

        .tile:hover {
            background-color: #3a3c43;
        }

        .tile-number {
            width: 50px;
            text-align: center;
            font-size: 18px;
            color: #b9bbbe;
            user-select: none;
        }

        .tile-image img {
            width: 64px;
            height: 64px;
            object-fit: contain;
            border-radius: 4px;
            user-select: none;
        }

        .tile-name {
            width: 300px;
            padding-left: 20px;
            font-size: 16px;
            color: #dcddde;
            font-weight: 600;
            user-select: text;
        }

        #tooltip {
            position: absolute;
            display: none;
            background: #18191c;
            border: 1px solid #202225;
            padding: 10px 12px;
            font-size: 14px;
            color: #dcddde;
            pointer-events: none;
            white-space: pre-line;
            max-width: 400px;
            border-radius: 5px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.9);
            z-index: 1000;
            user-select: none;
        }



        .ribbon {
            position: fixed;
            top: 0;
            right: 0;
            z-index: 9999;
            overflow: hidden;
            width: 150px;
            height: 150px;
            pointer-events: none;
        }

        .ribbon span {
            position: absolute;
            display: block;
            width: 225px;
            padding: 10px 0;
            background: #5865F2;
            color: white;
            text-align: center;
            font-weight: bold;
            font-family: sans-serif;
            text-transform: uppercase;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
            top: 30px;
            right: -55px;
            transform: rotate(45deg);
            pointer-events: auto;
        }

        /* Overlay full screen fond sombre transparent */
        #update-overlay {
            display: none;
            /* caché par défaut */
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(30, 30, 30, 0.9);
            backdrop-filter: blur(5px);
            z-index: 9999;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #ddd;
        }

        /* Box message centré */
        #update-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #2f3136;
            padding: 30px 40px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.7);
            text-align: center;
            max-width: 90%;
            width: 400px;
        }

        #update-box h2 {
            margin-bottom: 12px;
            font-size: 1.8em;
            color: #7289da;
            /* Discord blurple */
        }

        #update-box p {
            margin-bottom: 25px;
            font-size: 1.1em;
            line-height: 1.4;
            color: #b9bbbe;
        }

        #update-box button {
            background-color: #7289da;
            border: none;
            border-radius: 5px;
            padding: 12px 28px;
            color: white;
            font-weight: 600;
            font-size: 1em;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        #update-box button:hover {
            background-color: #5b6eae;
        }

        #last_profiles {
            border: 1px solid #72767d;
            background-color: #2f3136;
            width: 300px;
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            box-shadow: 5px 3px 8px rgba(0, 0, 0, 0.5);
            margin-bottom: 20px;
            position: absolute;
            padding-bottom: 4px;
            text-align: center;
            right: 20px;
            top: 150px;
        }

        #last_profiles h2 {
            margin-top: 0;
            color: #fff;
            font-size: 16px;
            width: 100%;
            text-align: center;
            margin-bottom: 0;
        }

        #last_profiles p {
            color: #b9bbbe;
            font-size: 14px;
            margin-bottom: 4px;
            width: 100%;
            text-align: center;
            margin-top: 5px;
        }

        li {
            list-style: none;
            margin: 5px 0;
            padding: 5px;
            background-color: #40444b;
            border-radius: 3px;
            color: #dcddde;
            font-size: 14px;
        }

        ul {
            padding: 0%;
            margin: 0;
        }
    </style>
    <script src="./js/jsQR.js"></script>
    <!-- Firebase App (compat) -->
    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
    <!-- Firebase Firestore (compat) -->
    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore-compat.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
</head>

<body>
    <a href="#" class="ribbon" title="Work in progress">
        <span>BETA VERSION</span>
    </a>
    <div id="main_container">
        <div id="header">
            <h1>Once Human - Memetics</h1>
        </div>
        <nav id="menu_bar">
            <a href="#qrcode_reader_container">QR Code Reader</a>
            <a href="create_profile_mm.html">Memetics Profile Generator</a>
        </nav>

        <div id="qrcode_reader_container">
            <h2>QR code reader:</h2>
            <p style="font-size:0.9em;">Upload a QR code image to decode and view the Memetics profile.</p>
            <p style="font-size:0.8em; color:#888;margin-bottom: 10px; margin-top: 0; padding: 0;"><i>Make sure the QR
                    code is generated by the Memetics Profile Generator.</i></p>
            <div class="qrframe" style="text-align:center;width:100%;">
                <div class="qrcanvas" style="width:100%;">
                    <canvas id="qrCanvas" style="display: none;"></canvas>
                </div>
                <div class="inputfile">
                    <label class="upload-button">
                        📷 Upload QR Code image
                        <input id="fileInput" type="file" accept="image/*" hidden>
                    </label>
                </div>
            </div>
        </div>
        <div id="result_container">
            <h2>Memetics Tiles</h2>
            <p>Hover over a tile to see its effect.</p>
            <div class="info" id="playerInfo"></div>
            <div id="tilesList"></div>
        </div>
    </div>
    <div id="last_profiles">
        <h2>Last Memetics Profiles</h2>
        <p>Last 3 profiles saved in the database:</p>
        <ul id="last_profiles_list"></ul>
        <div id="img_mm_pw"></div>
    </div>
    <footer style="background-color: #1e1f22; color: #888; text-align: center; padding: 5px; font-size: 0.85rem;">
        <p>Personal project by <strong>ketchu13</strong> aka <strong>Søuris</strong> — <span
                style="opacity: 0.8;">2025</span></p>
        <p style="font-size: 0.75rem; color: #666;">Not affiliated with Starry Studio or the game <em>Once Human</em>
        </p>
    </footer>
    <div id="tooltip"></div>
    <div id="update-overlay">
        <div id="update-box">
            <h2>Hey! 🚀 Update detected!</h2>
            <p>A new version of this page is available.<br />Please reload to get the latest and greatest.</p>
            <button id="reload-btn">Reload Now</button>
        </div>
    </div>
    <script>

        let memeticsData = [];
        let lastThreeProfiles = [];

        const params = new URLSearchParams(window.location.search);
        const profileID = params.get('profile_id');

        const imgempty = new Image();

        imgempty.src = './memetics_icons_cropped/empty.png';
        imgempty.width = 96;
        imgempty.height = 96;
        imgempty.alt = 'empty';
        // Configuration Firebase
        const firebaseConfig = {
            apiKey: "AIzaSyB2_wLWe9dElA_jqlkxkfLldBzXeXa5l8U",
            authDomain: "oncehumank13tools.firebaseapp.com",
            projectId: "oncehumank13tools",
            storageBucket: "oncehumank13tools.firebasestorage.app",
            messagingSenderId: "766110090627",
            appId: "1:766110090627:web:e8547f7018ff3777ff22b6",
            measurementId: "G-YX55LK87YH"
        };

        // Initialisation
        const app = firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();

        function compressAndEncode(data) {
            const binary = pako.deflate(data);
            return btoa(String.fromCharCode(...binary));
        }
        function decodeAndDecompress(encoded) {
            // Décodage base64 → binaire (Uint8Array)
            const binaryString = atob(encoded);
            const binary = new Uint8Array([...binaryString].map(c => c.charCodeAt(0)));

            // Décompression zlib
            const data = pako.inflate(binary, { to: 'string' });

            // Parse JSON
            return data;
        }
        async function getLastThreeProfiles() {
            try {
                const snapshot = await db
                    .collection("memetics_profiles")
                    .orderBy("createdAt")
                    .limit(3)
                    .get();

                const profiles = [];
                snapshot.forEach(doc => {
                    profiles.push({ id: doc.id, ...doc.data() });
                });

                console.log("Derniers profils :", profiles);
                return profiles;
            } catch (error) {
                console.error("Erreur lors de la récupération des profils :", error);
                return [];
            }
        }

        function saveProfileToFirestore(player, server, level, memetics) {
            const profileData = {
                player: player,
                server: server,
                level: level,
                memetics: memetics,
                createdAt: firebase.firestore.FieldValue.serverTimestamp()
            };

            return db.collection('memetics_profiles').add(profileData)
                .then(() => console.log('Profile saved successfully!'))
                .catch((error) => console.error('Error saving profile:', error));
        }
        async function getProfileById(id) {
            try {
                const docRef = db.collection("memetics_profiles").doc(id);
                const doc = await docRef.get();

                if (doc.exists) {
                    console.log("Profil trouvé :", doc.data());
                    return { id: doc.id, ...doc.data() };
                } else {
                    console.log("Aucun profil trouvé avec l'ID :", id);
                    return null;
                }
            } catch (error) {
                console.error("Erreur lors de la récupération du profil :", error);
                return null;
            }
        }
        async function getLatestCommitSHA(owner, repo, branch = 'main') {
            const url = `https://api.github.com/repos/${owner}/${repo}/commits/${branch}`;
            try {
                const response = await fetch(url);
                remaining = response.headers.get('X-RateLimit-Remaining');
                if (remaining === '0') {
                    console.warn('GitHub API rate limit reached. Please try again later.');
                    return null;
                }
                if (!response.ok) throw new Error(`GitHub API error: ${response.status}`);
                const data = await response.json();
                return data.sha.substring(0, 7);
            } catch (error) {
                console.error('Failed to fetch latest commit SHA:', error);
                return null;
            }
        }
        function loadLastThreeProfiles() {
            getLastThreeProfiles().then(profiles => {
                lastThreeProfiles = profiles;
                const list = document.getElementById('last_profiles_list');
                list.innerHTML = ''; // On vide la liste avant de la remplir à nouveau

                if (profiles.length === 0) {
                    list.innerHTML = '<li>No profiles found.</li>';
                    return;
                }

                profiles.forEach(profile => {
                    const li = document.createElement('li');
                    let player_name = "";
                    for (let i = 0; i < profile.player.length; i++) {
                        if (i >= 1 && i < profile.player.length - 1) {
                            player_name += '*';
                        } else {
                            player_name += profile.player[i];
                        }
                    }

                    li.textContent = `${player_name} (${profile.server})`;
                    li.dataset.id = profile.id;
                    const tooltip = document.getElementById('img_mm_pw');

                    li.addEventListener('mouseenter', () => {
                        generatPicture(profile.memetics, player_name, profile.server, tooltip);
                        tooltip.style.display = 'block';
                    });

                    li.addEventListener('mouseleave', () => {
                        tooltip.style.display = 'none';
                        tooltip.innerHTML = '';
                    });

                    li.onclick = (e) => {
                        e.stopPropagation();
                        // TODO : Ajouter une action au clic
                    };

                    list.appendChild(li);
                });
            });
        }
        function fitTextToWidth(ctx, text, maxWidth, initialFontSize = 13, minFontSize = 6, fontFamily = "Arial") {
            let fontSize = initialFontSize;

            // On descend jusqu'à ce que ça rentre ou qu'on atteigne la taille minimale
            while (fontSize >= minFontSize) {
                ctx.font = `${fontSize}px ${fontFamily}`;
                const metrics = ctx.measureText(text);
                if (metrics.width <= maxWidth) {
                    return fontSize;
                }
                fontSize -= 1;
            }

            // Si aucun ne passe, retourne la taille minimale
            return minFontSize;
        }

        function showUpdateOverlay() {
            document.getElementById('update-overlay').style.display = 'block';
        }
        function reloadPage() {
            // Tenter de vider le cache (reload complet)
            // location.reload(true) est déprécié, donc on force reload avec un timestamp unique dans l'URL
            const url = new URL(window.location.href);
            url.searchParams.set('_', Date.now());
            window.location.href = url.toString();
        }
        function startCheckingUpdates(owner, repo, branch = 'main', intervalMs = 300000) {
            let lastSHA = null;

            async function check() {
                const latestSHA = await getLatestCommitSHA(owner, repo, branch);
                if (!latestSHA) return;

                if (lastSHA && latestSHA !== lastSHA) {
                    console.log('Update detected! New commit:', latestSHA);
                    showUpdateOverlay();
                } else if (!lastSHA) {
                    console.log('Initial commit SHA:', latestSHA);
                } else {
                    console.log('No update. Current commit SHA:', latestSHA);
                }

                lastSHA = latestSHA;
            }

            check();
            setInterval(check, intervalMs);
        }

        function escapeHTML(str) {
            return String(str).replace(/[&<>"']/g, (m) => ({
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#39;',
            })[m]);
        }

        function generateMemeticsTableImage(part1, part2, levelImageMap) {
            const tileSize = 96; // taille de l'image
            const padding = 3;
            const fontSize = 13;
            const headerHeight = 50;
            const rowHeight = tileSize + padding;
            const rows = 5;
            const cols = 4;
            const canvasWidth = 13 + 30 + tileSize + 13 + 30 + tileSize + 13;
            const canvasHeight = headerHeight + rows * rowHeight + 13;

            const canvas = document.createElement('canvas');
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            canvas.style.borderRadius = '5px';
            const ctx = canvas.getContext('2d');
            //reduce size of part1 and part2 to 50
            part1 = part1.length > 20 ? part1.substring(0, 20) + '...' : part1;
            part2 = part2.length > 30 ? part2.substring(0, 30) + '...' : part2;
            if (part1.length + part2.length > 50) {
                part1 = part1.substring(0, 20) + '...';
                part2 = part2.substring(0, 30) + '...';
            }
            // Fond
            ctx.fillStyle = '#1e1e1e';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            // Header
            ctx.fillStyle = 'white';
            const fontSized = fitTextToWidth(ctx, `${part1} - ${part2}`, 545);
            ctx.font = `bold ${fontSized}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText(`${part1} - ${part2}`, canvasWidth / 2, 30);

            // Colonnes gauche (5 → 25) et droite (30 → 50)
            const leftLevels = [5, 10, 15, 20, 25];
            const rightLevels = [30, 35, 40, 45, 50];

            ctx.font = `${fontSize}px sans-serif`;
            ctx.textAlign = 'left';

            for (let i = 0; i < rows; i++) {
                const y = headerHeight + i * rowHeight + fontSize / 2 + rowHeight / 2;

                // Colonne 1 : niveau gauche
                ctx.fillStyle = 'white';
                ctx.fillText(`${leftLevels[i]}`, 13, y);

                // Colonne 2 : image gauche
                const imgLeft = levelImageMap[leftLevels[i]];
                if (imgLeft) {
                    ctx.drawImage(
                        imgLeft,
                        13 + 30,
                        headerHeight + i * rowHeight,
                        tileSize,
                        tileSize
                    );
                }

                // Colonne 3 : niveau droite
                ctx.fillText(`${rightLevels[i]}`, 13 + 30 + tileSize + 13, y);

                // Colonne 4 : image droite
                const imgRight = levelImageMap[rightLevels[i]];
                if (imgRight) {
                    ctx.drawImage(
                        imgRight,
                        13 + 30 + tileSize + 13 + 30,
                        headerHeight + i * rowHeight,
                        tileSize,
                        tileSize
                    );
                }
            }

            return canvas;
        }
        function generatPicture(profile_memetics, player_name, server, img_elem) {
            img_elem.style.display = 'block';
            img_elem.innerHTML = '';
            const levelImageMap = {};
            const imgempty = new Image();
            imgempty.src = './memetics_icons_cropped/empty.png';
            imgempty.width = 96;
            imgempty.height = 96;
            imgempty.alt = 'empty';
            for (let i = 5; i <= 50; i += 5) {
                levelImageMap[i] = imgempty; // initialise avec une image vide
            }
            profile_memetics.forEach((memeticId, index) => {
                if (memeticId) {
                    const memetic = memeticsData.find(m => m.id === parseInt(memeticId));
                    if (!memetic) {
                        console.warn(`Memetic with ID ${memeticId} not found.`);
                        return;
                    }
                    if (memetic) {
                        const img = new Image();
                        img.src = './memetics_icons_cropped/' + memetic.imgUrl;
                        img.width = 96;
                        img.height = 96;
                        img.alt = memetic.name;
                        levelImageMap[(index + 1) * 5] = img; // map niveau à l'image
                    }
                }
            });
            const part1 = player_name || 'Profile';
            const part2 = server || 'Server';
            const canvas_mm = generateMemeticsTableImage(part1, part2, levelImageMap);
            img_elem.appendChild(canvas_mm);
        }

        function generateTiles(userData) {
            if (!userData) {
                alert("Invalid JSON format: " + err.message);
                return;
            }

            // Afficher infos joueur
            const info = `
                <strong>Joueur :</strong> ${escapeHTML(userData.player) || 'N/A'}<br>
                <strong>Serveur :</strong> ${escapeHTML(userData.server) || 'N/A'}<br>
                <strong>Niveau :</strong> ${escapeHTML(userData.level) || 'N/A'}<br>
              `;
            document.getElementById('playerInfo').innerHTML = info;

            // Générer les tuiles
            const container = document.getElementById('tilesList');
            container.innerHTML = ''; // reset

            const slots = [5, 10, 15, 20, 25, 30, 35, 40, 45, 50];

            slots.forEach(slot => {
                if (userData.memetics['s' + slot]) {
                    const item = memeticsData.find(m => m.id === parseInt(userData.memetics['s' + slot]));
                    if (item) {
                        createTile(container, item, slot);
                    } else {
                        createTile(container, {
                            name: 'Not set..',
                            imgUrl: 'empty.png',
                            effect_description: 'No description available.',
                            effect_title: 'No Effect available.'
                        }, slot);
                    }
                } else {
                    console.warn(`No data for slot s${slot}`);
                }
            });
        }
        function createTile(container, item, slot) {

            const tileNumber = slot;
            const tooltip = document.getElementById('tooltip');
            const tile = document.createElement('div');

            tile.className = 'tile';
            tile.innerHTML = `
            <div class="tile-number">${tileNumber}</div>
            <div class="tile-image"><img src="./memetics_icons_cropped/${item.imgUrl}" alt="${item.name}"></div>
            <div class="tile-name">${item.name}</div>
            `;

            tile.addEventListener('mouseenter', e => {
                tooltip.innerHTML = `<strong>${item.effect_description}</strong><br>${item.effect_title}`;
                tooltip.style.display = 'block';
            });

            tile.addEventListener('mousemove', e => {
                tooltip.style.left = (e.pageX + 15) + 'px';
                tooltip.style.top = (e.pageY + 15) + 'px';
            });

            tile.addEventListener('mouseleave', () => {
                tooltip.style.display = 'none';
            });

            container.appendChild(tile);
        }

        function handleQRCodeUpload(input) {
            if (!input.files || input.files.length === 0) {
                alert("Please select a file.");
                return;
            }
            const file = input.files[0];
            if (!file) return;

            // Clear previous canvas
            const canvas = document.getElementById('qrCanvas');
            canvas.style.display = 'none';
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Read the uploaded file

            const reader = new FileReader();
            reader.onload = function () {
                const img = new Image();
                img.onload = function () {
                    const canvas = document.getElementById('qrCanvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const code = jsQR(imageData.data, canvas.width, canvas.height);
                    if (!code) {
                        alert("No QR code found in the image.");
                        return;
                    }
                    // display the canvas
                    canvas.style.display = 'inline';
                    if (code) {
                        try {
                            decoded_data = decodeAndDecompress(code.data);
                            // data format: player#server#level#s5,s10,s15...#
                            parsed_data = decoded_data.split('#');
                            parsed_memetics = parsed_data[3].split(',');
                            parsed_memeticsData = {};
                            slevel = [5, 10, 15, 20, 25, 30, 35, 40, 45, 50];
                            for (let i = 0; i < parsed_memetics.length; i++) {
                                parsed_memeticsData['s' + slevel[i]] = parsed_memetics[i];
                            }
                            const userData = {
                                player: parsed_data[0],
                                server: parsed_data[1],
                                level: parsed_data[2],
                                memetics: parsed_memeticsData,
                            };
                            //document.getElementById('userJson').value = JSON.stringify(json, null, 2);
                            generateTiles(userData);
                        } catch (err) {
                            alert("QR code content is not valid JSON.");
                        }
                    } else {
                        alert("No QR code found in the image.");
                    }
                };
                img.src = reader.result;
            };
            reader.readAsDataURL(file);
        }


        const fileInput = document.getElementById('fileInput');

        fileInput.addEventListener('click', () => {
            // Réinitialise la valeur AVANT de cliquer pour forcer le onchange
            fileInput.value = '';
        });

        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                handleQRCodeUpload(fileInput);
            }
        });
        // fonction async qui charge le JSON et le stocke
        async function loadJsonBeforePage() {
            try {
                const response = await fetch('./memetics.json');
                if (!response.ok) throw new Error('Erreur HTTP ' + response.status);
                const data = await response.json();
                memeticsData = data.memetics;
                populateSelects();
            } catch (e) {
                console.error('Erreur lors du chargement JSON:', e);
                // Tu peux choisir un fallback ici
                window.myGlobalDict = {};
            }
        }
        document.addEventListener('DOMContentLoaded', () => {
            loadJsonBeforePage()
                .then(() => {
                    console.log('Memetics data loaded successfully.');
                })
                .catch((error) => {
                    console.error('Failed to load memetics data:', error);
                });
            // Lancer la vérification
            startCheckingUpdates('ketchu13', 'oh_tools', 'main', 60 * 1000); // check toutes les 10 secondes
            // Charger une première fois au démarrage
            loadLastThreeProfiles();
            setInterval(() => {
                loadLastThreeProfiles();
            }, 30 * 1000); // Recharger toutes les 30 secondes pour le devbug
            //Ferme les dropdown si clic hors dropdown
            document.addEventListener('click', () => {
                document.querySelectorAll('.custom-dropdown .options.show').forEach((el) => {
                    el.classList.remove('show');
                });
            });

        });
        document.getElementById('reload-btn').addEventListener('click', reloadPage);

        if (profileID) {
            getProfileById(profileID).then(profile => {
                if (profile) {
                    parsed_memetics = {};
                    const levels = [5, 10, 15, 20, 25, 30, 35, 40, 45, 50];

                    levels.forEach((level, index) => {
                        parsed_memetics[`s${level}`] = String(profile.memetics[index]);
                    });
                    const userData = {
                        player: profile.player,
                        server: profile.server,
                        level: profile.level,
                        memetics: parsed_memetics,
                    };

                    generateTiles(userData);
                } else {
                    alert("Profile not found.");
                }
            });
        }
    </script>
</body>

</html>